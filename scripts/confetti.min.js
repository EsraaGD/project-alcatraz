window.ConfettiGenerator = function (e) {
    var a = {
        target: "confetti-holder",
        max: 80,
        size: 1,
        animate: true,
        props: ["circle", "square", "triangle", "line"],
        colors: [[165, 104, 246], [230, 61, 135], [0, 199, 228], [253, 214, 126]],
        clock: 25,
        interval: null,
        width: window.innerWidth,
        height: window.innerHeight
    };

    if (e) {
        if (e.target) a.target = e.target;
        if (e.max) a.max = e.max;
        if (e.size) a.size = e.size;
        if (e.animate !== undefined && e.animate !== null) a.animate = e.animate;
        if (e.props) a.props = e.props;
        if (e.colors) a.colors = e.colors;
        if (e.clock) a.clock = e.clock;
        if (e.width) a.width = e.width;
        if (e.height) a.height = e.height;
    }

    var o = document.getElementById(a.target);
    if (!o) {
        console.error("Canvas element with id '" + a.target + "' not found.");
        return null;
    }
    var n = o.getContext("2d"),
        l = [];

    function t(e, t) {
        e || (e = 1);
        var i = Math.random() * e;
        return t ? Math.floor(i) : i
    }

    function i() {
        return {
            prop: a.props[t(a.props.length, true)],
            x: t(a.width),
            y: t(a.height),
            radius: t(4) + 1,
            line: Math.floor(t(65) - 30),
            angles: [t(10, true) + 2, t(10, true) + 2, t(10, true) + 2, t(10, true) + 2],
            color: a.colors[t(a.colors.length, true)],
            rotation: t(360, true) * Math.PI / 180,
            speed: t(a.clock / 7) + a.clock / 30
        }
    }

    function r(e) {
        var t = e.radius <= 3 ? .4 : .8;
        switch (n.fillStyle = n.strokeStyle = "rgba(" + e.color + ", " + t + ")", n.beginPath(), e.prop) {
            case "circle":
                n.moveTo(e.x, e.y), n.arc(e.x, e.y, e.radius * a.size, 0, 2 * Math.PI, !0), n.fill();
                break;
            case "triangle":
                n.moveTo(e.x, e.y), n.lineTo(e.x + e.angles[0] * a.size, e.y + e.angles[1] * a.size), n.lineTo(e.x + e.angles[2] * a.size, e.y + e.angles[3] * a.size), n.closePath(), n.fill();
                break;
            case "line":
                n.moveTo(e.x, e.y), n.lineTo(e.x + e.line * a.size, e.y + 5 * e.radius), n.lineWidth = 2 * a.size, n.stroke();
                break;
            case "square":
                n.save(), n.translate(e.x + 15, e.y + 5), n.rotate(e.rotation), n.fillRect(-15 * a.size, -5 * a.size, 15 * a.size, 5 * a.size), n.restore()
        }
    }

    function s() {
        for (var e = 0; e < a.max; e++) {
            var i = l[e];
            a.animate && (i.y += i.speed), i.y > a.height && (l[e] = i, l[e].x = t(a.width, true), l[e].y = -10)
        }
    }

    function c() {
        n.clearRect(0, 0, a.width, a.height);
        for (var e in l) r(l[e]);
        s()
    }
    return {
        render: function () {
            o.width = a.width, o.height = a.height, l = [];
            for (var e = 0; e < a.max; e++) l.push(i());
            return a.animate ? a.interval = setInterval(c, 20) : c(), this
        },
        clear: function () {
            n.clearRect(0, 0, o.width, o.height);
            var e = o.width;
            return o.width = 1, o.width = e, clearInterval(a.interval), this
        }
    }
};
